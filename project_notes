Notes to help organize what I want to do next. I often find myself creating a few day plan and then forgetting it before
I start working again.

Detailing next steps (5-11-18)

currently working on the pipline of complex object construction.
at the start should be a set of entities (qualities included?)
at the end will be a new node that is the complex object, which can then be linked to other objects.

finished the complex universe constructor. This was simpler than expected. One thing I want to do is to
turn it into a recursive function, or multiple; one that will extract more complicated objects higher up the
meta-universe chain. I imagine doing this with different paths could yield some interesting results.

The first step to extending my meta universe is to find a common quality between n objects that is higher up the meta

I ran into a problem with connor just now. I asked him to give me a quality of a quality "organized" and he said "the
positioning of things" a sentence. How do I go from

      sentence ==> complex quality         **I have a solution for this: I will turn an input sentence into its own
      and then                              complex universe, then I will save that universe as a complex quality of
      complex qualities ==> sentences       the 'spoken of' object, or objects.  I NEED TO BE CAREFUL WITH MY TYPES

   I was watching my cousins play a game and i thought it was quite interesting; miranda pointed out that "everyone
   circles things"
   I realized that this was to tighten the interpreting apparatus of the people to take only one object,that object they
   were set to describe. There was a scene presented on paper, usually just symbols to que the person in on the semantic
   region they were meant to inhabit. This reminded me of my complex (sub)universes and a way of extracting individual
   symbols like 'doctor' out of the medical cloud. The doctor is an entity, and it has the quality person of which no
   other symbol presented in the complex universe has. This seems to maybe be related to my

Currying types around my now more dynamic system (5-12-18)

I actually ended up simply using my add_arc function after my creation of a complex universe set to turn the whole damn
thing into another node in my system. I think this will be fine for now; the setified version of my complex constructor
will be used in the more complex versions of the constructor (which will in the end be a large set of heuristic functions.)

 (5-14-18)

 I think the next step should really be to consider how to organically add nodes to my network. I can use packages for
 parsing/tokenizing and the like, but I still don't know what the nitty-gritty of node addition is. On top of this, I
 don't know exactly how I'm going to PROVIDE FEEDBACK TO THE NODE ADDITION ALGORITHM in order to maintain a fair amount
 of consistence in my graph. If there is an object with several inconsistent qualities it could lead to some pretty
 strange results when the graph is queried. The charm of my system is the lack of required feedback, but I do think a lot
 will still be necessary.


(12-18-18)

    I want to pause for a minute and consider the need for me to write my graph onto an external file or database. I think
the only place the python program uses is ram as it runs. I read a lot about the memory manegement system 'malloc' that
python uses which was pretty awesome. Pools and Arenas and what not. Memory allocation and garbage collection are all
words I brushed up with. Anyway once my graph gets big enough it's gonna want to live somewhere. Plus I'll want a place
where I can save any number of variations of my graph object as I create them with SEPERATE TEST SCRIPTS TO RUN. This
means all of my printing and adding vertices and all of this can be written to a seperate file and then used independantly
to generate different graphs.
    So it's actually between writing text files, writing to a database (can I put my nested dict in a flat table??) or yeah
I think that's it. Perhaps text will be necessary. There's also the possibility of piggybacking off of one of the existing
graph packages and storing it in there. I could even possibly inherit the functionality directly into my class, will have
to do some research on the feasibility of that though.

Oh another question I had was whether or not to use a sepereat class to create universes. I mean they are technically seperate
objects but the way I have it set up now is to just name the universe a code based on the first letter of it's constituents
and then save it right back into the central graph. This might be a bad idea because what I really want to do is dynamically
create universes that only need to exist for the duration of the complex construction process. I can save the Ce and Cq back
into the main graph, but I think it would be best to just keep the Cu in the air to be garbage collected after use.

I just got into it willy nilly but I think I should think carefully here and actually plan out my currying of data and
all of the rest. I'll write it down physically to get an idea of the structure. THE CU CLASS IS USED TO CREATE AN INSTANCE
OF CU THAT ONLY NEEDS TO LAST LONG ENOUGH FOR MY COMPLEX CONSTUCTION TO USE IT. Should my complex construction take place
in seperate classes too? I mean I am creating seperate dictionary objects BUT they should all fit back nicely into the main
graph. I can avoid needing to stick every node together by just saving them in the C dictionaries and plugging the Co back
into the main graph, so maybe it would be good to create those objects as seperate class instances for easy take out and observation?

Just learned it's good style to put a single underscore at the beginning of a variable? for internal use.

12-19-18
Thinking about some of the longer range design principles I want to implement. I'm not really sure if I want to throw
all of my functions into one page and one class maybe even, and then just implement them from a run page. I'm thinking
the run page should involve user input but honestly I don't see why I would ever really need to have a ui. I do need to
find a way to perhaps save different suites of run commands and also graphs too. I mean I need to save the graphs I come
up with but they wont be very useful to me without the run commands they came with, so I'll probably just save those as
their own py files. I can import my main graph from there, the main class page will have all of the tools needed to manipulate
the graph. It doesn't seem like python really wants me to be able to save it with the graph as an instance attribute. I mean
when I try to inherit it it just wants to inherit the object representation of it instead of the actual dict. I can
see the dict in my debugger hiding just under the object rep but I'm not sure how to access it directly. So I tried to pass
the dictionary object created by the class intstance in my run commands and it worked. I will have to be careful about
what this means for dependencies and everything. I mean who will have access to the object and how?
    I think this points to me just needing to use separate classes and sort of chopping up my graph and returning my constructed
pieces after my various constructors have their way with them. I really need to start thinking about the way in which this
might happen. I really need some paper though?

      run.py                  classpage?.py               data.py? (consider database to read/write from)
      commands to               The meat and potatoes.      where the graph will write to
      run. Various              functions do operations
      operations on             on the graph itself
      the graph will
      be tried here.
      Hopefully I can
      write novel combos
      to this

      class structure
      MainGraph - generates object. adds arcs and nodes performs main construction operations as well as queries such as e_q?
      Universe - creates the Cu and other types of objects which set the stage for further complex constructions. Will
      contain complex universe construction on many levels--which I have yet to decide will entail staggered constructions or just depth
      first. I think I should save the intelligent staggering for Complex constuctions.

12-20-18
I think I should also be thinking about how I'm going to write the actual 'add to the graph intelligently' stuff. I would
like to be able to read a string and then add to the graph accordingly. My idea so far is to simply make a Cu out of the
words in the string and then.... hmmm. I really have to think about this some more. It's the nitty gritty of node addition
like I point out in some of my notes on paper. I need to go to the drawing board and lay down some groudwork for future
writing if I want this things structure to turn out decent.

1-3-19
having a really hard time figuring out if I need to store my graph dictionary elsewhere or if I can just generate it and
keep it in memory. I mean I never really need to access the whole thing at once unless I'm printing it out.
One thing I do need to do though is traverse through multiple levels within a function though. When I get to a value that
is also another node, stored as a key on the same level, I can jump from the value to the key easily with the hashing
lookup. I might have to do more thinking on this. And it might actually be true that I have to wait to see some more details
of how my constructors will operate.

I need to access the whole graph, or at least all of the keys whenever I look something up. And actually I might have some
functions that pull all of the values from all keys and search them with set methods, this might get a little tricky, but
with no one to ask I just don't really know how to go about it. It will be a learning experience lol.

1-6-19
I think I'm going to just keep the graph in memory for now. I think it will take a while for it to get really big, and even
when it is strings don't take up a ton of memory.
Perhaps keeping my dictionary smaller by focusing on pruning and other 'less-meaning correction methods', ways to wring
out the useless complex objects in favor for more meaningful ones. The nitty gritty of this still needs a lot of thought.

What I mainly need to work on now is my complex constructions, as well as my nitty-gritty of node addition from strings.
I have my complex universe, so I want to add more layers to that, as well as to make my ce/cq constructions from it.
I need to revisit the index set ideas, I have a feeling I might end up with a lot more than just a few staggered Co constructors.
This needs a little bit of planning/design before I start coding.
I also will work more on my node addition from strings. I had a few good ideas about this the other day and am feeling a
bit more optimistic, I was worried this would be the most difficult thing to do.

I forgot that my node addition is going to require my complex constructions to help it add nodes (most likely?) I'm not sure
it might just have to be a messy co-creation lol.

1-8-19
I just got an incredible and unexpected result!
"""
L1Cu
{'Burns': 1, 'word': 1, 'Person': 1}
L1Cq
{'Burns', 'student', 'word', 'Person'}
l1co:
{'l1co-BsP': 'l1cu-MC', 'l1co-PwB': 'l1cu-MA'}"""

When I plugged in my alpha nodes to my complex constructors, I got every permutation of similarity between them!
Actually this may be because I already called my cc's on MC... regardless I need to refocus on redifining my complex
universe to be bigger and my complex quality needs to save arcs going from it's constituents to it in order to trace
back from a L1Cq without needing to use the signifier (first lettters)
******
So I really didn't have an incredible result, not yet at least. I'm not sure what happened honestly. Looking back at it
looks like it could be cool though. it's almost like what I wanted to do, but it creates multiple objects for multiple
purmutations of universe members. I'm not sure if that's what it did but if it did I don't know how the fuck lol.
I rewrote the entire thing, designing from the ground up. It now looks like this

        L1CU(*nodes, union=False)  => l1cu_-q : q, q, q    #universe takes common q and saves with parent labeled qqq
        L1Cq(L1Cu(*nodes))         => l1cq-n : q, q, q     #quality takes common q and saves with parent
        L1Co(L1Cq(L1Cu(*nodes)))   => n, n, n, n

Thats enough of that. My comments should be enough honestly. So this is actually a huge win for me and I should acknowledge
that. This is the main structure I had in mind when I first conceived of this. Now I will move on to more complicated
versions of the constructions. Ones with varying levels of depth, lookup/quality triangulation, and other params. I also
think I can start working on the first versions of my node addition class. Perhaps I will design something with my complex
constructions in mind before I go typing away. I think I ought to slow down a bit more, I basically rewrote everything three
times, which it seems like I could avoid.

1-15-19
Working on my naming convention right now. I want to generate novel codes only if there is an extant one at that level,
so I have to check the level in my name creation. Then I will save the name in another dict with the level as it's value.

1-20-19
finished my naming convention with a dynamic concatenation 'level' which will tack on the type of object to the name. It
will finally only check for names that are already in that level, and will add an 'x' if true.
I want to expand my object construction to include fuzzy relations and fuzzy levels of depth. I've thought on a few ways,
such as offering up a ratio as a constant value to assign relatedness to the central meaning being explored.

1-29-19:
"Sentences organize items in the world"



TODO begin writing/designing node addition class
TODO think on how to avoid naming collisions (check for extant name before naming function)(not sure if done)

